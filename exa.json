{
    "language": "Solidity",
    "sources": {
        "contracts/Validators.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"./System.sol\";\nimport \"./interfaces/ISlash.sol\";\n\n/**\n * @title Validators Contract - With Delegator Rewards\n * @notice CLI Compatible + Delegator Reward Functions\n * @dev Carefully implemented to not break existing functionality\n */\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction underflow\");\n        return a - b;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n}\n\ncontract Validators is System {\n    using SafeMath for uint256;\n\n    uint16 public constant MaxValidatorNum = 101;\n    uint64 public constant StakingLockPeriod = 86400;\n    uint64 public constant WithdrawRewardPeriod = 28800;\n    uint256 public constant MinimalStakingCoin = 10000 ether;\n    uint256 public constant ValidatorSlashAmount = 500 ether;\n    uint256 public constant MinimalOfStaking = 1000 ether;\n\n    enum Status {\n        NotExist,\n        Created,\n        Staked,\n        Unstake,\n        Jailed\n    }\n\n    struct Description {\n        string moniker;\n        string website;\n        string email;\n        string details;\n    }\n\n    struct Validator {\n        address payable rewardAddr;\n        Status status;\n        uint256 stakingAmount;\n        Description description;\n        uint256 rewardAmount;\n        uint256 slashAmount;\n        uint256 lastWithdrawRewardBlock;\n        address[] stakers;\n        uint256 commissionRate;\n        uint256 delegatorRewardPool;\n        uint256 accRewardPerStake;\n        uint256 accSlashPerStake;\n    }\n\n    struct StakingInfo {\n        uint256 amount;\n        uint256 unstakeBlock;\n        uint256 index;\n    }\n\n    struct DelegatorRewardInfo {\n        uint256 rewardDebt;\n        uint256 pendingRewards;\n        uint256 lastClaimBlock;\n    }\n\n    mapping(address => Validator) public validatorInfo;\n    mapping(address => mapping(address => StakingInfo)) public stakerInfo;\n    address[] public validatorCandidateSet;\n    address[] public validatorSet;\n    uint256 public totalStaking;\n\n    ISlash slash;\n    \n    uint256 distributedRewardNumber;\n    uint256 updateValidatorNumber;\n    \n    mapping(address => bool) validatorCandidateExists;\n    uint256 public constant DEFAULT_COMMISSION_RATE = 500;\n    uint256 public constant MAX_COMMISSION_RATE = 1000;\n\n    mapping(address => mapping(address => DelegatorRewardInfo)) public delegatorRewardInfo;\n    uint256 private constant PRECISION_FACTOR = 1e18;\n\n    event ValidatorCreated(address indexed validator, address indexed rewardAddr);\n    event ValidatorUpdated(address indexed validator, address indexed rewardAddr);\n    event ValidatorUnjailed(address indexed validator);\n    event Unstake(address indexed staker, address indexed validator, uint256 amount, uint256 unLockHeight);\n    event Staking(address indexed staker, address indexed validator, uint256 amount);\n    event WithdrawStaking(address indexed staker, address indexed validator, uint256 amount);\n    event WithdrawRewards(address indexed validator, address indexed rewardAddress, uint256 amount, uint256 nextWithdrawBlock);\n    event RewardDistributed(address[] validators, uint256[] rewards, uint256 rewardCount);\n    event ValidatorSlash(address indexed validator, uint256 amount);\n    event ValidatorSetUpdated(address[] validators);\n    event AddToValidatorCandidate(address indexed validator);\n    event RemoveFromValidatorCandidate(address indexed validator);\n    event DelegatorRewardsClaimed(address indexed delegator, address indexed validator, uint256 amount);\n\n    modifier onlyNotRewarded() {\n        require(block.number > distributedRewardNumber, \"Block is already rewarded\");\n        _;\n        distributedRewardNumber = block.number;\n    }\n\n    modifier onlyNotUpdated() {\n        require(block.number > updateValidatorNumber, \"Validators already updated\");\n        _;\n        updateValidatorNumber = block.number;\n    }\n\n    function initialize(address[] calldata validators) external onlyNotInitialized {\n        slash = ISlash(SlashContractAddr);\n        admin = msg.sender;\n\n        for (uint256 i = 0; i < validators.length; i++) {\n            require(validators[i] != address(0), \"Invalid validator address\");\n\n            if (!isValidatorCandidate(validators[i])) {\n                validatorCandidateSet.push(validators[i]);\n                validatorCandidateExists[validators[i]] = true;\n            }\n            \n            if (!isValidatorActivated(validators[i])) {\n                validatorSet.push(validators[i]);\n            }\n            \n            if (validatorInfo[validators[i]].rewardAddr == address(0)) {\n                validatorInfo[validators[i]].rewardAddr = payable(validators[i]);\n            }\n            \n            if (validatorInfo[validators[i]].status == Status.NotExist) {\n                validatorInfo[validators[i]].status = Status.Staked;\n            }\n\n            if (validatorInfo[validators[i]].commissionRate == 0) {\n                validatorInfo[validators[i]].commissionRate = DEFAULT_COMMISSION_RATE;\n            }\n        }\n\n        initialized = true;\n    }\n\n    function create(\n        address payable rewardAddr,\n        string calldata moniker,\n        string calldata website,\n        string calldata email,\n        string calldata details\n    ) external payable onlyInitialized whenNotPaused returns (bool) {\n        address payable validator = payable(msg.sender);\n        require(validatorInfo[validator].status == Status.NotExist, \"validator already exist\");\n        \n        uint256 stakingAmount = msg.value;\n        _updateValidator(validator, rewardAddr, moniker, website, email, details);\n        validatorInfo[validator].commissionRate = DEFAULT_COMMISSION_RATE;\n        \n        emit ValidatorCreated(validator, rewardAddr);\n        \n        if (stakingAmount > 0) {\n            return _stake(validator, validator, stakingAmount);\n        }\n        \n        return true;\n    }\n\n    function edit(\n        address payable rewardAddr,\n        string calldata moniker,\n        string calldata website,\n        string calldata email,\n        string calldata details\n    ) external onlyInitialized whenNotPaused returns (bool) {\n        address payable validator = payable(msg.sender);\n        require(validatorInfo[validator].status != Status.NotExist, \"validator isn't exist\");\n        \n        _updateValidator(validator, rewardAddr, moniker, website, email, details);\n        emit ValidatorUpdated(validator, rewardAddr);\n        return true;\n    }\n\n    function stake(address validator) external payable onlyInitialized whenNotPaused returns (bool) {\n        address payable staker = payable(msg.sender);\n        uint256 stakingAmount = msg.value;\n        return _stake(staker, validator, stakingAmount);\n    }\n\n    function _stake(address staker, address validator, uint256 stakingAmount) private returns (bool) {\n        require(validatorInfo[validator].status != Status.NotExist, \"validator is not exist\");\n        require(stakerInfo[staker][validator].unstakeBlock == 0, \"can't stake when you are unstaking\");\n        require(stakingAmount >= MinimalOfStaking, \"staking amount must more than 1000cet\");\n        \n        Validator storage valInfo = validatorInfo[validator];\n        require(\n            valInfo.stakingAmount + stakingAmount >= MinimalStakingCoin,\n            \"staking amount must more than 10000cet\"\n        );\n\n        _updateDelegatorRewards(staker, validator);\n\n        if (stakerInfo[staker][validator].amount == 0) {\n            stakerInfo[staker][validator].index = valInfo.stakers.length;\n            valInfo.stakers.push(staker);\n        }\n\n        valInfo.stakingAmount = valInfo.stakingAmount + stakingAmount;\n        if (valInfo.status != Status.Staked && valInfo.status != Status.Jailed) {\n            valInfo.status = Status.Staked;\n        }\n\n        stakerInfo[staker][validator].amount = stakerInfo[staker][validator].amount + stakingAmount;\n        totalStaking = totalStaking + stakingAmount;\n        \n        delegatorRewardInfo[staker][validator].rewardDebt = \n            (stakerInfo[staker][validator].amount.mul(valInfo.accRewardPerStake)).div(PRECISION_FACTOR);\n        \n        emit Staking(staker, validator, stakingAmount);\n\n        if (valInfo.status == Status.Staked) {\n            addToValidatorCandidate(validator, valInfo.stakingAmount);\n        }\n\n        return true;\n    }\n\n    function unstake(address validator) external onlyInitialized whenNotPaused returns (bool) {\n        address staker = msg.sender;\n        require(validatorInfo[validator].status != Status.NotExist, \"validator is not exist\");\n\n        _updateDelegatorRewards(staker, validator);\n\n        StakingInfo storage stakingInfo = stakerInfo[staker][validator];\n        Validator storage valInfo = validatorInfo[validator];\n        uint256 unstakeAmount = stakingInfo.amount;\n\n        require(stakingInfo.unstakeBlock == 0, \"you are already in unstaking status\");\n        require(unstakeAmount > 0, \"you don't have any stake\");\n        require(\n            !(validatorSet.length == 1 &&\n                isValidatorActivated(validator) &&\n                valInfo.stakingAmount - unstakeAmount < MinimalStakingCoin),\n            \"you can't unstake, validator list will be empty after this operation\"\n        );\n\n        if (stakingInfo.index != valInfo.stakers.length - 1) {\n            valInfo.stakers[stakingInfo.index] = valInfo.stakers[valInfo.stakers.length - 1];\n            stakerInfo[valInfo.stakers[stakingInfo.index]][validator].index = stakingInfo.index;\n        }\n        valInfo.stakers.pop();\n\n        valInfo.stakingAmount = valInfo.stakingAmount - unstakeAmount;\n        stakingInfo.unstakeBlock = block.number;\n        stakingInfo.index = 0;\n        totalStaking = totalStaking - unstakeAmount;\n\n        if (valInfo.stakingAmount < MinimalStakingCoin) {\n            valInfo.status = Status.Unstake;\n        }\n\n        uint256 unLockHeight = block.number + StakingLockPeriod + 1;\n        emit Unstake(staker, validator, unstakeAmount, unLockHeight);\n\n        if (valInfo.status != Status.Staked) {\n            removeFromValidatorCandidate(validator);\n        }\n        return true;\n    }\n\n\n    function unjailed() external onlyInitialized whenNotPaused returns (bool) {\n        address validator = msg.sender;\n        require(validatorInfo[validator].status == Status.Jailed, \"validator isn't jailed\");\n        require(slash.clean(validator), \"clean slash reward failed\");\n\n        if (validatorInfo[validator].stakingAmount >= MinimalStakingCoin) {\n            validatorInfo[validator].status = Status.Staked;\n            addToValidatorCandidate(validator, validatorInfo[validator].stakingAmount);\n        } else {\n            validatorInfo[validator].status = Status.Unstake;\n        }\n\n        emit ValidatorUnjailed(validator);\n        return true;\n    }\n\n    function withdrawStaking(address validator) external returns (bool) {\n        address payable staker = payable(msg.sender);\n        StakingInfo storage stakingInfo = stakerInfo[staker][validator];\n        \n        require(validatorInfo[validator].status != Status.NotExist, \"validator not exist\");\n        require(stakingInfo.unstakeBlock != 0, \"you have to unstake first\");\n        require(\n            stakingInfo.unstakeBlock + StakingLockPeriod <= block.number,\n            \"your staking haven't unlocked yet\"\n        );\n        require(stakingInfo.amount > 0, \"you don't have any stake\");\n\n        uint256 staking = stakingInfo.amount;\n        stakingInfo.amount = 0;\n        stakingInfo.unstakeBlock = 0;\n\n        staker.transfer(staking);\n        emit WithdrawStaking(staker, validator, staking);\n        return true;\n    }\n\n    function withdrawRewards(address validator) external returns (bool) {\n        address payable rewardAddr = payable(msg.sender);\n        \n        require(validatorInfo[validator].status != Status.NotExist, \"validator not exist\");\n        require(\n            validatorInfo[validator].rewardAddr == rewardAddr,\n            \"you are not the reward receiver of this validator\"\n        );\n        require(\n            validatorInfo[validator].lastWithdrawRewardBlock + WithdrawRewardPeriod <= block.number,\n            \"you must wait enough blocks to withdraw your reward after latest withdraw of this validator\"\n        );\n        \n        uint256 rewardAmount = validatorInfo[validator].rewardAmount;\n        require(rewardAmount > 0, \"you don't have any reward\");\n\n        validatorInfo[validator].rewardAmount = 0;\n        validatorInfo[validator].lastWithdrawRewardBlock = block.number;\n\n        if (rewardAmount > 0) {\n            rewardAddr.transfer(rewardAmount);\n        }\n        \n        uint256 nextWithdrawBlock = block.number + WithdrawRewardPeriod + 1;\n        emit WithdrawRewards(validator, rewardAddr, rewardAmount, nextWithdrawBlock);\n        return true;\n    }\n\n    function distributeBlockReward() external payable onlyCoinbase onlyNotRewarded onlyInitialized onlyBlockEpoch {\n        uint256 amount = msg.value;\n        if (amount > 0) {\n            _distributeRewardToActivatedValidators(amount, address(0));\n        }\n    }\n\n    function _distributeRewardToActivatedValidators(uint256 rewardAmount, address exceptAddress) private {\n        if (rewardAmount == 0) return;\n\n        uint256 totalRewardStaking = 0;\n        uint256 rewardValidatorLen = 0;\n        \n        for (uint256 i = 0; i < validatorSet.length; i++) {\n            if (validatorInfo[validatorSet[i]].status != Status.Jailed && validatorSet[i] != exceptAddress) {\n                totalRewardStaking = totalRewardStaking + validatorInfo[validatorSet[i]].stakingAmount;\n                rewardValidatorLen++;\n            }\n        }\n        \n        if (rewardValidatorLen == 0) return;\n\n        address[] memory rewardValidators = new address[](rewardValidatorLen);\n        uint256[] memory validatorRewardAmount = new uint256[](rewardValidatorLen);\n        uint256 rewardCount = 0;\n        uint256 distributedAmount = 0;\n        \n        for (uint256 i = 0; i < validatorSet.length; i++) {\n            if (validatorInfo[validatorSet[i]].status != Status.Jailed && validatorSet[i] != exceptAddress) {\n                uint256 reward;\n                if (totalRewardStaking == 0) {\n                    reward = rewardAmount / rewardValidatorLen;\n                } else {\n                    reward = (rewardAmount * validatorInfo[validatorSet[i]].stakingAmount) / totalRewardStaking;\n                }\n                \n                uint256 commission = (reward * validatorInfo[validatorSet[i]].commissionRate) / 10000;\n                uint256 delegatorReward = reward - commission;\n                \n                validatorInfo[validatorSet[i]].rewardAmount = validatorInfo[validatorSet[i]].rewardAmount + commission;\n                \n                if (validatorInfo[validatorSet[i]].stakingAmount > 0 && delegatorReward > 0) {\n                    validatorInfo[validatorSet[i]].delegatorRewardPool = \n                        validatorInfo[validatorSet[i]].delegatorRewardPool + delegatorReward;\n                    \n                    validatorInfo[validatorSet[i]].accRewardPerStake = \n                        validatorInfo[validatorSet[i]].accRewardPerStake + \n                        (delegatorReward.mul(PRECISION_FACTOR).div(validatorInfo[validatorSet[i]].stakingAmount));\n                }\n                \n                rewardValidators[rewardCount] = validatorSet[i];\n                validatorRewardAmount[rewardCount] = reward;\n                rewardCount++;\n                distributedAmount = distributedAmount + reward;\n            }\n        }\n\n        uint256 remain = rewardAmount - distributedAmount;\n        if (remain > 0 && rewardCount > 0) {\n            validatorInfo[rewardValidators[rewardCount - 1]].rewardAmount = \n                validatorInfo[rewardValidators[rewardCount - 1]].rewardAmount + remain;\n            validatorRewardAmount[rewardCount - 1] = validatorRewardAmount[rewardCount - 1] + remain;\n        }\n\n        emit RewardDistributed(rewardValidators, validatorRewardAmount, rewardCount);\n    }\n\n    \n    /**\n     * @notice Update pending rewards for a delegator\n     * @dev Internal function to update rewards before any state change\n     */\n    function _updateDelegatorRewards(address delegator, address validator) private {\n        StakingInfo storage stakingInfo = stakerInfo[delegator][validator];\n        Validator storage valInfo = validatorInfo[validator];\n        DelegatorRewardInfo storage rewardInfo = delegatorRewardInfo[delegator][validator];\n        \n        if (stakingInfo.amount > 0) {\n            uint256 accReward = stakingInfo.amount.mul(valInfo.accRewardPerStake).div(PRECISION_FACTOR);\n            uint256 pending = accReward.sub(rewardInfo.rewardDebt);\n            \n            if (pending > 0) {\n                rewardInfo.pendingRewards = rewardInfo.pendingRewards.add(pending);\n            }\n        }\n        \n        rewardInfo.rewardDebt = stakingInfo.amount.mul(valInfo.accRewardPerStake).div(PRECISION_FACTOR);\n    }\n    \n    /**\n     * @notice Claim pending rewards for delegator\n     * @param validator Address of the validator\n     */\n    function claimDelegatorRewards(address validator) external returns (bool) {\n        address payable delegator = payable(msg.sender);\n        \n        _updateDelegatorRewards(delegator, validator);\n        \n        DelegatorRewardInfo storage rewardInfo = delegatorRewardInfo[delegator][validator];\n        uint256 claimable = rewardInfo.pendingRewards;\n        \n        require(claimable > 0, \"No rewards to claim\");\n        \n        rewardInfo.pendingRewards = 0;\n        rewardInfo.lastClaimBlock = block.number;\n        \n        Validator storage valInfo = validatorInfo[validator];\n        if (valInfo.delegatorRewardPool >= claimable) {\n            valInfo.delegatorRewardPool = valInfo.delegatorRewardPool.sub(claimable);\n        } else {\n            claimable = valInfo.delegatorRewardPool;\n            valInfo.delegatorRewardPool = 0;\n        }\n        \n        delegator.transfer(claimable);\n        \n        emit DelegatorRewardsClaimed(delegator, validator, claimable);\n        return true;\n    }\n    \n    /**\n     * @notice Get pending rewards for a delegator\n     * @param delegator Address of the delegator\n     * @param validator Address of the validator\n     */\n    function getPendingDelegatorRewards(address delegator, address validator) external view returns (uint256) {\n        StakingInfo memory stakingInfo = stakerInfo[delegator][validator];\n        Validator memory valInfo = validatorInfo[validator];\n        DelegatorRewardInfo memory rewardInfo = delegatorRewardInfo[delegator][validator];\n        \n        if (stakingInfo.amount == 0) {\n            return rewardInfo.pendingRewards;\n        }\n        \n        uint256 accReward = stakingInfo.amount.mul(valInfo.accRewardPerStake).div(PRECISION_FACTOR);\n        uint256 pending = accReward.sub(rewardInfo.rewardDebt);\n        \n        return rewardInfo.pendingRewards.add(pending);\n    }\n    \n    /**\n     * @notice Get total pending rewards across all validators\n     * @param delegator Address of the delegator\n     */\n    function getTotalPendingRewards(address delegator) external view returns (uint256 total) {\n        total = 0;\n        for (uint256 i = 0; i < validatorCandidateSet.length; i++) {\n            address validator = validatorCandidateSet[i];\n            StakingInfo memory stakingInfo = stakerInfo[delegator][validator];\n            \n            if (stakingInfo.amount > 0) {\n                Validator memory valInfo = validatorInfo[validator];\n                DelegatorRewardInfo memory rewardInfo = delegatorRewardInfo[delegator][validator];\n                \n                uint256 accReward = stakingInfo.amount.mul(valInfo.accRewardPerStake).div(PRECISION_FACTOR);\n                uint256 pending = accReward.sub(rewardInfo.rewardDebt);\n                \n                total = total.add(rewardInfo.pendingRewards.add(pending));\n            }\n        }\n    }\n    \n    /**\n     * @notice Batch claim rewards from multiple validators\n     * @param validators Array of validator addresses\n     */\n    function batchClaimRewards(address[] calldata validators) external returns (uint256 totalClaimed) {\n        address payable delegator = payable(msg.sender);\n        totalClaimed = 0;\n        \n        for (uint256 i = 0; i < validators.length; i++) {\n            _updateDelegatorRewards(delegator, validators[i]);\n            \n            DelegatorRewardInfo storage rewardInfo = delegatorRewardInfo[delegator][validators[i]];\n            uint256 claimable = rewardInfo.pendingRewards;\n            \n            if (claimable > 0) {\n                rewardInfo.pendingRewards = 0;\n                rewardInfo.lastClaimBlock = block.number;\n                \n                Validator storage valInfo = validatorInfo[validators[i]];\n                if (valInfo.delegatorRewardPool >= claimable) {\n                    valInfo.delegatorRewardPool = valInfo.delegatorRewardPool.sub(claimable);\n                } else {\n                    claimable = valInfo.delegatorRewardPool;\n                    valInfo.delegatorRewardPool = 0;\n                }\n                \n                totalClaimed = totalClaimed.add(claimable);\n                emit DelegatorRewardsClaimed(delegator, validators[i], claimable);\n            }\n        }\n        \n        if (totalClaimed > 0) {\n            delegator.transfer(totalClaimed);\n        }\n        \n        return totalClaimed;\n    }\n\n    function getValidatorCandidate() public view returns (address[] memory, uint256[] memory, uint256) {\n        address[] memory candidates = new address[](validatorCandidateSet.length);\n        uint256[] memory stakings = new uint256[](validatorCandidateSet.length);\n        uint256 count = 0;\n        \n        for (uint256 i = 0; i < validatorCandidateSet.length; i++) {\n            if (validatorInfo[validatorCandidateSet[i]].status == Status.Staked) {\n                candidates[count] = validatorCandidateSet[i];\n                stakings[count] = validatorInfo[validatorCandidateSet[i]].stakingAmount;\n                count++;\n            }\n        }\n        return (candidates, stakings, count);\n    }\n\n    function getValidatorInfo(address validator) public view returns (\n        address payable,\n        Status,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        address[] memory\n    ) {\n        Validator memory v = validatorInfo[validator];\n        return (\n            v.rewardAddr,\n            v.status,\n            v.stakingAmount,\n            v.rewardAmount,\n            v.slashAmount,\n            v.lastWithdrawRewardBlock,\n            v.stakers\n        );\n    }\n\n    function getValidatorDescription(address validator) public view returns (\n        string memory,\n        string memory,\n        string memory,\n        string memory\n    ) {\n        Validator memory v = validatorInfo[validator];\n        return (\n            v.description.moniker,\n            v.description.website,\n            v.description.email,\n            v.description.details\n        );\n    }\n\n    function getStakingInfo(address staker, address validator) public view returns (\n        uint256,\n        uint256,\n        uint256\n    ) {\n        return (\n            stakerInfo[staker][validator].amount,\n            stakerInfo[staker][validator].unstakeBlock,\n            stakerInfo[staker][validator].index\n        );\n    }\n\n    function getActivatedValidators() public view returns (address[] memory) {\n        return validatorSet;\n    }\n\n    function isValidatorActivated(address validator) public view returns (bool) {\n        for (uint256 i = 0; i < validatorSet.length; i++) {\n            if (validatorSet[i] == validator) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function isValidatorCandidate(address who) public view returns (bool) {\n        for (uint256 i = 0; i < validatorCandidateSet.length; i++) {\n            if (validatorCandidateSet[i] == who) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function isJailed(address validator) public view returns (bool) {\n        return validatorInfo[validator].status == Status.Jailed;\n    }\n\n    function validateDescription(\n        string memory moniker,\n        string memory website,\n        string memory email,\n        string memory details\n    ) public pure returns (bool) {\n        require(bytes(moniker).length <= 128, \"invalid moniker length\");\n        require(bytes(website).length <= 256, \"invalid website length\");\n        require(bytes(email).length <= 256, \"invalid email length\");\n        require(bytes(details).length <= 1024, \"invalid details length\");\n        return true;\n    }\n\n    function updateActivatedValidators() public onlyCoinbase onlyNotUpdated onlyInitialized onlyBlockEpoch returns (address[] memory) {\n        require(validatorCandidateSet.length > 0, \"validator set empty\");\n        require(validatorCandidateSet.length <= MaxValidatorNum, \"validator can't more than 101\");\n        \n        validatorSet = validatorCandidateSet;\n        emit ValidatorSetUpdated(validatorSet);\n        return validatorSet;\n    }\n\n    function slashValidator(address validator) external onlySlashContract {\n        if (!isValidatorActivated(validator)) return;\n\n        Validator storage valInfo = validatorInfo[validator];\n        valInfo.status = Status.Jailed;\n        uint256 stakingAmount = valInfo.stakingAmount;\n        deactivateValidator(validator);\n        removeFromValidatorCandidate(validator);\n\n        if (stakingAmount == 0) return;\n\n        uint256 slashTotal = 0;\n        for (uint256 i = 0; i < valInfo.stakers.length; i++) {\n            StakingInfo storage stakingInfo = stakerInfo[valInfo.stakers[i]][validator];\n            uint256 stakerSlashAmount = (stakingInfo.amount * ValidatorSlashAmount) / stakingAmount;\n            stakingInfo.amount = stakingInfo.amount - stakerSlashAmount;\n            slashTotal = slashTotal + stakerSlashAmount;\n        }\n        \n        valInfo.stakingAmount = valInfo.stakingAmount - slashTotal;\n        valInfo.slashAmount = valInfo.slashAmount + slashTotal;\n\n        _distributeRewardToActivatedValidators(slashTotal, validator);\n        emit ValidatorSlash(validator, slashTotal);\n    }\n\n    function _updateValidator(\n        address payable validator,\n        address payable rewardAddr,\n        string calldata moniker,\n        string calldata website,\n        string calldata email,\n        string calldata details\n    ) private returns (bool) {\n        require(rewardAddr != address(0), \"invalid receive reward address\");\n        require(validateDescription(moniker, website, email, details), \"invalid validator description\");\n        \n        if (validatorInfo[validator].status == Status.NotExist) {\n            validatorInfo[validator].status = Status.Created;\n        }\n\n        validatorInfo[validator].rewardAddr = rewardAddr;\n        validatorInfo[validator].description = Description(moniker, website, email, details);\n        \n        return true;\n    }\n\n    function addToValidatorCandidate(address validator, uint256 staking) internal returns (bool) {\n        if (validatorCandidateExists[validator]) return true;\n\n        if (validatorCandidateSet.length < MaxValidatorNum) {\n            validatorCandidateSet.push(validator);\n            validatorCandidateExists[validator] = true;\n            emit AddToValidatorCandidate(validator);\n            return true;\n        }\n\n        uint256 lowestStaking = validatorInfo[validatorCandidateSet[0]].stakingAmount;\n        uint256 lowestIndex = 0;\n        \n        for (uint256 i = 1; i < validatorCandidateSet.length; i++) {\n            if (validatorInfo[validatorCandidateSet[i]].stakingAmount < lowestStaking) {\n                lowestStaking = validatorInfo[validatorCandidateSet[i]].stakingAmount;\n                lowestIndex = i;\n            }\n        }\n\n        if (staking <= lowestStaking) return false;\n\n        emit RemoveFromValidatorCandidate(validatorCandidateSet[lowestIndex]);\n        validatorCandidateExists[validatorCandidateSet[lowestIndex]] = false;\n        \n        validatorCandidateSet[lowestIndex] = validator;\n        validatorCandidateExists[validator] = true;\n        emit AddToValidatorCandidate(validator);\n        \n        return true;\n    }\n\n    function removeFromValidatorCandidate(address validator) internal {\n        if (!validatorCandidateExists[validator]) return;\n\n        for (uint256 i = 0; i < validatorCandidateSet.length && validatorCandidateSet.length > 1; i++) {\n            if (validatorCandidateSet[i] == validator) {\n                if (i != validatorCandidateSet.length - 1) {\n                    validatorCandidateSet[i] = validatorCandidateSet[validatorCandidateSet.length - 1];\n                }\n                validatorCandidateSet.pop();\n                validatorCandidateExists[validator] = false;\n                emit RemoveFromValidatorCandidate(validator);\n                break;\n            }\n        }\n    }\n\n    function deactivateValidator(address validator) private {\n        for (uint256 i = 0; i < validatorSet.length && validatorSet.length > 1; i++) {\n            if (validator == validatorSet[i]) {\n                if (i != validatorSet.length - 1) {\n                    validatorSet[i] = validatorSet[validatorSet.length - 1];\n                }\n                validatorSet.pop();\n                break;\n            }\n        }\n    }\n\n    receive() external payable {}\n}"
        },
        "contracts/System.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\n/**\n * @title System Base Contract\n * @notice Base contract for Validators and Slash contracts\n */\nabstract contract System {\n    bool public initialized;\n    bool public paused;\n    address public admin;\n\n    address public constant ValidatorContractAddr = 0x0000000000000000000000000000000000001000;\n    address public constant SlashContractAddr = 0x0000000000000000000000000000000000001001;\n    uint256 public constant BlockEpoch = 200;\n\n    event Paused();\n    event Unpaused();\n    event AdminChanged(address indexed previousAdmin, address indexed newAdmin);\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Only admin can call this function\");\n        _;\n    }\n\n    modifier whenNotPaused() {\n        require(!paused, \"Contract is paused\");\n        _;\n    }\n\n    modifier onlyCoinbase() {\n        require(msg.sender == block.coinbase, \"the message sender must be the block producer\");\n        _;\n    }\n\n    modifier onlyNotInitialized() {\n        require(!initialized, \"the contract already initialized\");\n        _;\n    }\n\n    modifier onlyInitialized() {\n        require(initialized, \"the contract not init yet\");\n        _;\n    }\n\n    modifier onlySlashContract() {\n        require(msg.sender == SlashContractAddr, \"the message sender must be slash contract\");\n        _;\n    }\n\n    modifier onlyValidatorsContract() {\n        require(msg.sender == ValidatorContractAddr, \"the message sender must be validator contract\");\n        _;\n    }\n\n    modifier onlyBlockEpoch() {\n        require(block.number % BlockEpoch == 0, \"Block epoch only\");\n        _;\n    }\n\n    function pause() external onlyAdmin {\n        require(!paused, \"Already paused\");\n        paused = true;\n        emit Paused();\n    }\n\n    function unpause() external onlyAdmin {\n        require(paused, \"Not paused\");\n        paused = false;\n        emit Unpaused();\n    }\n\n    function changeAdmin(address newAdmin) external onlyAdmin {\n        require(newAdmin != address(0), \"Invalid admin address\");\n        emit AdminChanged(admin, newAdmin);\n        admin = newAdmin;\n    }\n}"
        },
        "contracts/interfaces/ISlash.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\n/**\n * @title ISlash Interface\n * @dev Interface for Slash contract to break circular dependency\n */\ninterface ISlash {\n    function clean(address validator) external returns (bool);\n    function getSlashRecord(address validator) external view returns (uint256);\n}\n"
        }
    },
    "settings": {
        "remappings": [
            "@ensdomains/=node_modules/@ensdomains/",
            "@openzeppelin/=node_modules/@openzeppelin/",
            "eth-gas-reporter/=node_modules/eth-gas-reporter/",
            "hardhat/=node_modules/hardhat/",
            "truffle/=node_modules/truffle/"
        ],
        "optimizer": {
            "enabled": false,
            "runs": 200
        },
        "metadata": {
            "useLiteralContent": false,
            "bytecodeHash": "ipfs",
            "appendCBOR": true
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "evm.bytecode.object",
                    "evm.bytecode.sourceMap",
                    "evm.bytecode.linkReferences",
                    "evm.deployedBytecode.object",
                    "evm.deployedBytecode.sourceMap",
                    "evm.deployedBytecode.linkReferences",
                    "evm.deployedBytecode.immutableReferences",
                    "evm.methodIdentifiers",
                    "metadata"
                ]
            }
        },
        "evmVersion": "istanbul",
        "viaIR": false,
        "libraries": {}
    }
}